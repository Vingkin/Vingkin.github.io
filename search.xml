<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018-10-31]]></title>
    <url>%2F%E8%AE%B0%2F2018-10-31%2F2018-10-31%2F</url>
    <content type="text"><![CDATA[2018-10-31 2018.10.31 &nbsp;&nbsp; 周三 &nbsp;&nbsp; 晴 最近总感觉自己很失败，身边的人都逐渐离去，都不知道该找谁去聊天了。好像本来就很少和人聊天吧。话虽然本身就不多，但好像越来越少了。看着每天练习的ACM，仿佛已经快迷失了自己。对于身边的人也存着戒备之心，所以话自然就少了下来吧。有点讨厌现在的日子，还有现在的自己。 吴边是肯定靠不住的，还有今天晚上和唐元清讨论题目的时候，他竟然突然和许幸满说去超市，丢下了我，还是挺难受的。挺希望这样的生活能有所改变。现在只能一个人，忍着内心的痛苦，含泪记录下这些。这样的自己真讨厌。]]></content>
      <categories>
        <category>记</category>
        <category>2018-10-31</category>
      </categories>
      <tags>
        <tag>记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有点迷茫]]></title>
    <url>%2F%E8%AE%B0%2F%E6%9C%89%E7%82%B9%E8%BF%B7%E8%8C%AB%2F%E6%9C%89%E7%82%B9%E8%BF%B7%E8%8C%AB%2F</url>
    <content type="text"><![CDATA[有点迷茫 2018.10.28 &nbsp;&nbsp; 周日 &nbsp;&nbsp; 晴 昨天和今天感觉都是形式上的去学习，不知道为什么最近有点静不下心来。平时不怎么学习的坤最近都是格外的认真，出奇的是几乎他整个宿舍的人都去复习了，头一次这么多人复习，挺羡慕这种氛围的。准备下下个星期就开始考研的复习了，选择考研是不满足于现在的现状，但是自己现在的努力又配不上考研，真的是有点矛盾呢。一定要很努力地去获得什么呢，不然对不起现在的自己。 下周末不出意外的话应该就是最后一次ICPC比赛了呢。差不多今年4月份刚入的坑，短短的半年时间里真的改变了我太多太多。第一次省赛成功爆零，那次才是第一次看到了原来人与人之间的差距可以这么大。再后来暑假去了大校培训了40天，这40天全程住在宾馆，每天也是差不多在学校做到9点才回去，这40天的进步应该还是有目共睹的，可以说在某种意义上改变了我也不为过吧，但是这个差距仿佛已经不可逾越了。培训结束后就开始上学了，有点开始讨厌这个学校，厌恶高中的自己，所以只能借助考研来改变这一切。然后就是最近的南京ICPC了，虽然没有爆零，但是基本是也已经是垫底了。希望青岛能够超长发挥吧，加油吧。]]></content>
      <categories>
        <category>记</category>
        <category>有点迷茫</category>
      </categories>
      <tags>
        <tag>记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[灰魔法师]]></title>
    <url>%2FACM%2F%E6%80%9D%E7%BB%B4%2F%E7%81%B0%E9%AD%94%E6%B3%95%E5%B8%88%2F</url>
    <content type="text"><![CDATA[灰魔法师链接：https://www.nowcoder.com/acm/contest/215/A 题目描述“White shores, and beyond. A far green country under a swift sunrise.”—灰魔法师 给出长度为n的序列a, 求有多少对数对$(i,j)$$(1 \leq i &lt; j \leq n)$满足 $a_i + a_j$为完全平方数。 输入描述 第一行一个整数 n $(1\leq n\leq 10^5)$第二行 n 个整数 $a_i$ $(1\leq a_i\leq 10^5)$ 输出描述 输出一个整数，表示满足上述条件的数对个数。 示例 输入31 3 6输出2说明满足条件的有$(1,2),(2,3)$两对。 代码123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6+5;int vis[maxn];long long ans = 0, n;int main()&#123; int x; cin &gt;&gt; n; for(int i=1; i&lt;=n; i++) &#123; cin &gt;&gt; x; for(int j=1; j&lt;=500; j++) &#123; if(j*j-x&gt;=0) ans += vis[j*j-x]; &#125; vis[x]++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Molly's Chemicals]]></title>
    <url>%2FACM%2F%E5%89%8D%E7%BC%80%E5%92%8C%2FMolly-s-Chemicals%2F</url>
    <content type="text"><![CDATA[Molly’s Chemicals链接：http://codeforces.com/contest/776/problem/C 题目描述Molly Hooper has n different kinds of chemicals arranged in a line. Each of the chemicals has an affection value, The i-th of them has affection value $a_i$. Molly wants Sherlock to fall in love with her. She intends to do this by mixing a contiguous segment of chemicals together to make a love potion with total affection value as a non-negative integer power of k. Total affection value of a continuous segment of chemicals is the sum of affection values of each chemical in that segment. Help her to do so in finding the total number of such segments. InputThe first line of input contains two integers, n and k, the number of chemicals and the number, such that the total affection value is a non-negative power of this number k.$(1\leq n\leq 10^5, 1\leq |k|\leq 10)$. Next line contains n integers $a_1, a_2,\cdots , a_n(-10^9\leq a_i\leq 10^9)$—affection values of chemicals. OutputOutput a single integer—the number of valid segments. Examples input4 22 2 2 2output8input4 -33 -6 -3 12output3 题意大致是求数组中某一段的和等于k的次幂，即sum[r]-sum[l]==pow(k,x);枚举数组的话是$O(n^2)$，对于1e5来说肯定是超时的，所以转变思路sum[r]-pow(k,x)==sum[l]。转而枚举前缀和的一边和k的幂。注意k是可以为负数的，所以不能先全部把ma[s[i]]++预处理出来，可能出现l&gt;r的情况从而计数重复。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+5;int n, k;long long s[maxn];map&lt;long long, int&gt; ma;set&lt;long long&gt; a;int main()&#123; ma.clear(); a.clear(); cin &gt;&gt; n &gt;&gt; k; s[0] = 0; for(int i=1; i&lt;=n; i++) &#123; cin &gt;&gt; s[i]; s[i] += s[i-1]; &#125; long long tmp = 1; for(int i=1; i&lt;=60; i++) &#123; if(tmp&gt;1e14) break; a.insert(tmp); tmp *= k; &#125; long long ans = 0; ma[0] = 1; for(int i=1; i&lt;=n; i++) &#123; for(auto j=a.begin(); j!=a.end(); j++) &#123; ans += ma[s[i]-*j]; &#125; ma[s[i]]++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>前缀和</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Board]]></title>
    <url>%2FACM%2F%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98%2FBoard%2F</url>
    <content type="text"><![CDATA[Board链接：https://www.nowcoder.com/acm/contest/206/B 题目描述恬恬有一个$n\times n$的数组。她在用这个数组玩游戏：开始时，数组中每一个元素都是0。恬恬会做某些操作。在一次操作中，她可以将某一行的所有元素同时加上一个值，也可以将某一列的所有元素同时加上一个值。在几次操作后，一个元素被隐藏了。你能帮助她回忆隐藏的数是几吗？ 输入描述第一行一个整数n$(1\leq n\leq 1000)$。接下来n行每行n个整数表示数组a。第(i+1)行的第j个元素表示$a_{i,j}$$(a_{i,j}=-1或0\leq a_{i,j}\leq 10000)$。-1表示隐藏的元素。 输出描述仅一个整数表示答案。 实例： 输入31 2 10 -1 00 1 0输出1 题目其实就是一个染色问题，假设有n种颜色，那么每次插入值就相当于插入了n个各不相同的颜色。最后，每个颜色的个数应该相等。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;int n, tmp[maxn], s[maxn][maxn];int main()&#123; cin &gt;&gt; n; for(int i=0; i&lt;n; i++) for(int j=0; j&lt;n; j++) cin &gt;&gt; s[i][j]; memset(tmp, 0, sizeof tmp); for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;n; j++) &#123; if(s[i][j]!=-1) tmp[(i+j)%n] += s[i][j]; &#125; &#125; sort(tmp, tmp+n); cout &lt;&lt; tmp[1]-tmp[0] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>染色问题</category>
      </categories>
      <tags>
        <tag>染色问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那时的你 那时的我]]></title>
    <url>%2F%E8%AE%B0%2F%E6%85%95%E7%84%B6%E5%9B%9E%E9%A6%96%2F%E6%85%95%E7%84%B6%E5%9B%9E%E9%A6%96%2F</url>
    <content type="text"><![CDATA[那时的你 &nbsp; 那时的我 2018.10.22 &nbsp;&nbsp; 周一 &nbsp;&nbsp; 小雨 不知道为什么前天晚上突然想起了高一时和胡志恒的点点滴滴。突然回忆涌入脑海，不免有点伤感。总的来说就是很可惜吧。现在想起来，你给我的感觉就是很真实，可是或许就是在错误的时间遇到了正确的你吧。中途你删过我好友，可是不知道为什么，我们俩的聊天记录竟然还在！！！之后你说过“你不喜欢软弱的人”、“不要再觉得可能”，现在到看这些，不免还是有点心痛。当然也痛恨当时的软弱。现在早已不再软弱了，可是你也就消失不见了。现在才发现当时我们竟然说了这么多，然后就是时隔两年多的沉默。 记得当时是11月16号旅游的，前天晚上我答应你帮你下一点bigbang的歌，然后我们就莫名其妙的在一起了，在分开后，你说当时真的很感动，其实这种话是最让人难过的了。当然只是在一起了两个星期，不知道为什么这两个星期的事情我几乎一点也想不起来，只记得你冲过去抱了周跃，我懵了，然后聊天记录记录了一切。当时你无聊的时候还会找找我，突然感觉当时自己的情商真的好低。对了，想起来了我们准备一起去食堂吃午饭来着，然后莫名其妙没吃成，或许这就是缘分吧，注定了要分开。聊天记录停留在了2014.2.28。哇，都快五年了，时间过的可太快了，两年前的一句“看到高总说说我还以为你弯了”，开始了我们时隔好久的对话，当然，也几乎只有那么一次，然后就到了现在。 以后还能见到的话都是缘分的吧，我们也早就不是一个世界的人了，喜欢也是不可能的了吧，只是现在好想抱抱你，当时的我一次也没抱过你，不过还是算了吧，再见吧。]]></content>
      <categories>
        <category>记</category>
        <category>慕然回首</category>
      </categories>
      <tags>
        <tag>记</tag>
        <tag>慕然回首</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习指南]]></title>
    <url>%2FGit%2FGit%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%2FGit%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Git学习指南第一章基础命令 git init创建一个版本库，用于存储该项目本身及其历史。 git add确定哪些文件应被包含在下次提交中。 git commit将修改传送到版本库中，并赋予该提交一个散列值以便表示这次新提交。 git status显示出该项目自上次提交以来发生的所有修改。 git diff显示其每个被修改的行。 git rm删除文件 git log用来显示项目的历史，所有提交都会按时间顺序被降序排列出来。 git clone克隆版本库 git pull将原版本库中的提交传递给他的克隆体。pull命令只在克隆版本库中发挥作用，因为只有该克隆体中有默认的原版本库的连接。也可以用参数来制定任意版本库的路径，以便从某一特定开发分支中提取相关修改。 git pushpush命令只适用于那些没有开发者在上面开展具体工作的版本库。最好的办法就是创建一个不带工作区的版本库，我们称之为裸版本库。 git clone --bare创建一个裸版本库。裸版本库通常可被用来充当开发者们传递提交（使用push命令）的汇聚点，以便他人可以从中拉回他们所做的修改。 本章小结 工作区域版本库： 工作区是一个包含$.git$子目录（内涵版本库）中的目录。我们可以用init命令在当前目录中创建版本库。 版本提交： 一次版本提交通常定义了版本库中所有文件的一个版本，他详细说明了该版本是由何人在何时何地创建的。当然，我们需要用add命令来确定哪些文件将被纳入下一次提交，然后再用commit命令创建新的版本提交。 查看信息： 通过status命令，我们可以查看哪些文件已被本地修改，以及哪些修改将被纳入下次提交。另外，log命令可用来显示提交历史。diff命令可用来显示两个版本文件之间的差异。 克隆： 对于用clone命令创建某一版本库的副本，我们称之为该版本库的克隆体。在一般情况下，每个开发者都会拥有整个项目版本库的完整克隆体，他/她的工作区中将会包含完整的项目历史。这使他们可以各自独立开展工作，无需连接服务器。 推送与拉回： push与pull命令可用于在本地和远程版本库之间共享版本提交。]]></content>
      <categories>
        <category>Git</category>
        <category>Git学习指南</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令]]></title>
    <url>%2Flinux%E5%91%BD%E4%BB%A4%2Flinux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux命令1 mkdir 创建文件夹 mkdir demo 2 ls 显示文件和目录信息 ls -a 查询所有文件，包涵文件名以.开头的隐藏文件 3 cp 将原文件复制到目标文件 cp -r dir1 dir2 复制dir1目录所有东西到dir2 4 rm 删除 rm -r 文件/文件夹 5 find 查找 find 查找位置 -name 文件名 -print 查找文件 find 18300 -name a.cpp -print 6 cat 显示文本文件内容 cat a.cpp 7 less 分页显示文件内容，可用PgDn和PgUp翻页 less a.cpp less -N a.cpp 显示行号 8 groupadd 添加用户组 groupadd vingkin 9 groupdel 删除指定用户组 groupdel vingkin 10 useradd 添加用户 -g 指定用户所属的主用户组 -G 指定用户的附加用户组 -n 取消建立以用户名称为名的用户组 -r 建立系统账号 -s 指定用户登录shell -u 指定用户ID号 -m 自动建立用户登录后的用户主目录 -d 指定用户登陆后的主用户目录 useradd -g g1 -G g2, g3 user1 建立用户user1，g1为主用户组，g2和g3为附加用户组groups user1 显示user1所属的用户组 11 passwd 建立用户的登录密码 passwd user1 设置user1的登录密码 12 ps 显示系统进程的状态和属性 ps -r 显示正在运行的进程 ps -a 显示所有终端上运行的进程 ps -efj 显示所有进程 13 fg 将指定作业号的作业从后台切换至前台 fg 作业号 fg 1 14 bg 将指定作业号的后台暂停进程继续运行 bg 作业号 bg 1 15 jobs 显示当前控制台中的后台进程的状态 jobs]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高斯消元]]></title>
    <url>%2FACM%2F%E6%95%B0%E8%AE%BA%2F%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%2F%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%2F</url>
    <content type="text"><![CDATA[高斯消元 模板 12345678910111213141516171819202122232425262728293031323334// 此模板只能解决有解的情况，// 但是可以通过定义解决无穷解与无解的情况// c[][]储存的是系数矩阵// b[]储存的是尾数矩阵// 最终a[][]是一个对角线矩阵void Gauss()&#123; for(int i=1; i&lt;=n; i++) &#123; for(int j=i; j&lt;=n; j++) &#123; if(fabs(c[j][i])&gt;eps) &#123; for(int k=1; k&lt;=n; k++) &#123; swap(c[i][k], c[j][k]); &#125; swap(b[i], b[j]); &#125; &#125; for(int j=1; j&lt;=n; j++) &#123; if(i==j) continue; double rate = c[j][i]/c[i][i]; for(int k=i; k&lt;=n; k++) c[j][k] -= c[i][k]*rate; b[j] -= b[i]*rate; &#125; &#125; for(int i=1; i&lt;n; i++) printf(&quot;%.3lf &quot;, b[i]/c[i][i]); printf(&quot;%.3lf\n&quot;, b[n]/c[n][n]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盛金公式]]></title>
    <url>%2FACM%2F%E6%95%B0%E8%AE%BA%2F%E7%9B%9B%E9%87%91%E5%85%AC%E5%BC%8F%2F%E7%9B%9B%E9%87%91%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[盛金公式一元三次方程$ax^3+bx^2+cx+d=0(a,b,c,d\in R,a\neq 0)$ 重根判别式 \begin{cases} A=b^2-3ac\\ B=bc-9ad\\ C=c^2-3bd\\ \end{cases}总判别式 $\Delta =B^2-4AC$ 盛金公式1：当A=B=0时，$X_1=X_2=X_3=\frac{-b}{3a}=\frac{-c}{b}=\frac{-3d}{c}$ 盛金公式2：当$\Delta =B^2-4AC&gt;0$时，$X_1=\frac{-b-(\sqrt[3]{Y_1}+\sqrt[3]{Y_2})}{3a}$$X_{2,3}=\frac{-b+\frac{1}{2}(\sqrt[3]{Y_1}+\sqrt[3]{Y_2})\pm \frac{\sqrt[]{3}}{2}(\sqrt[3]{Y_1}-\sqrt[3]{Y_2})i}{3a}$其中$Y_{1,2}=Ab+3a(\frac{-B\pm \sqrt[]{B^2-4AC}}{2}),i^2=-1$。 盛金公式3：当$\Delta =B^2-4AC=0$时，$X_1=\frac{-b}{a}+K$;$X_{2,3}=\frac{-K}{2}$;其中$K=\frac{B}{A},(A\neq 0)$。 盛金公式4：当$\Delta =B^2-4AC&lt;0$时，$X_1=\frac{-b-2\sqrt[]{A}cos\frac{\theta}{3}}{3a}$;$X_{2,3}=\frac{-b+\sqrt[]{A}(cos\frac{\theta}{3}\pm \sqrt[]{3}sin\frac{\theta}{3})}{3a}$;其中$\theta =arccosT$$T=\frac{2Ab-3aB}{2A\sqrt[]{A}}$。]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
        <category>盛金公式</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sonya and Robots]]></title>
    <url>%2FACM%2F%E6%8E%92%E5%BA%8F%2FSonya-and-Robots%2F</url>
    <content type="text"><![CDATA[Sonya and Robots $time$ $limit$ $per$ $test$:$1$ $second$$memory$ $limit$ $per$ $test$:$256$ $megabytes$$input$:$standard$ $input$$output$:$standard$ $output$ Since Sonya is interested in robotics too, she decided to construct robots that will read and recognize numbers. Sonya has drawn $n$ numbers in a row, $a_i$ is located in the $i-th$ position. She also has put a robot at each end of the row (to the left of the first number and to the right of the last number). Sonya will give a number to each robot (they can be either same or different) and run them. When a robot is running, it is moving toward to another robot, reading numbers in the row. When a robot is reading a number that is equal to the number that was given to that robot, it will turn off and stay in the same position. Sonya does not want robots to break, so she will give such numbers that robots will stop before they meet. That is, the girl wants them to stop at different positions so that the first robot is to the left of the second one. For example, if the numbers $[1,5,4,1,3]$ are written, and Sonya gives the number $1$ to the first robot and the number $4$ to the second one, the first robot will stop in the $1-st$ position while the second one in the $3-rd$ position. In that case, robots will not meet each other. As a result, robots will not be broken. But if Sonya gives the number $4$ to the first robot and the number $5$ to the second one, they will meet since the first robot will stop in the $3-rd$ position while the second one is in the $2-nd$ position. Sonya understands that it does not make sense to give a number that is not written in the row because a robot will not find this number and will meet the other robot. Sonya is now interested in finding the number of different pairs that she can give to robots so that they will not meet. In other words, she wants to know the number of pairs $(p,q)$ , where she will give $p$ to the first robot and $q$ to the second one.Pairs $(p_i,q_i)$and $(p_j,q_j)$ are different if $p_i\neq p_j$ or $q_i\neq q_j$. Unfortunately, Sonya is busy fixing robots that broke after a failed launch. That is why she is asking you to find the number of pairs that she can give to robots so that they will not meet. InputThe first line contains a single integer $n$ $(1\leq n\leq 10^5)$ — the number of numbers in a row.The second line contains $n$ integers $a_1,a_2,\cdots ,a_n(1\leq a_i\leq 10^5)$ — the numbers in a row. OutputPrint one number — the number of possible pairs that Sonya can give to robots so that they will not meet. Examples Input 5 1 5 4 1 3 Output 9 Input 7 1 2 1 1 1 3 2 Output 7 HintIn the first example, Sonya can give pairs $(1,1)$,$(1,3)$,$(1,4)$,$(1,5)$,$(4,1)$,$(4,3)$,$(5,1)$,$(5,3)$,and$(5,4)$.In the second example, Sonya can give pairs $(1,1)$,$(1,2)$,$(1,3)$,$(2,1)$,$(2,2)$,$(2,3)$,and$(3,2)$. Analyses这题的题意是给你一个序列，你需要组成一个数对，数对满足不能重复，不能与自己组，而且数对左边的数在原序列上也在右边的数的左边，也就是相对位置不能改变。这题刚开始还不会写，还是太菜了啊，或许是stl还不会用，看一个wf大佬的代码后恍然大悟，对set又有了更深的认识，红黑树牛皮，不得不说set在去重和排序上还是很强的。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;list&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;#define ms(s) memset(s, 0, sizeof(s))const int inf = 0x3f3f3f3f;const int maxn = 1e5+5;ll s[maxn], n, ans=0;ll num[maxn];set&lt;int&gt; a;int main(int argc, char * argv[]) &#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; for(int i=1; i&lt;=n; i++) cin &gt;&gt; s[i]; for(int i=n; i&gt;=1; i--) &#123; a.insert(s[i]); num[i] = a.size(); &#125; a.clear(); for(int i=1; i&lt;=n; i++) &#123; if(a.find(s[i])==a.end()) &#123; a.insert(s[i]); ans += num[i+1]; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL]]></title>
    <url>%2FACM%2FSTL%2FSTL%2F</url>
    <content type="text"><![CDATA[C++ STLvectorsize/empty$size$函数返回$vector$的实际长度(包含的元素个数)，$empty$函数返回一个$bool$类型，表明$vector$是否为空。二者的时间复杂度都是$O(1)$;所有的STL容器都有这两个方法，含义也相同。 clear$clear$函数把$vector$数组清空。 迭代器迭代器就像STL容器的“指针”，可以用星号“*”操作符解除引用。一个保存$int$的$vector$的迭代器声明方法为：vector&lt; int&gt;::iterator it;$vector$的迭代器是“随机访问迭代器”，可以把$vector$的迭代器与一个整数相加减，其行为和指针的移动类似。可以把$vector$的两个迭代器相减，其结果也和指针相减类似，得到两个迭代器对应下标之间的距离。 begin/end$begin$函数返回指向$vector$中第一个元素的迭代器。例如$a$是一个非空的$vector$，则$*a.begin()$与$a[0]$的作用相同。所有的容器都可以视作一个“前闭后开”的结构，$end$函数返回$vector$的尾部，即第$n$个元素再往后的“边界”。$*end()$与$a[n]$都是越界访问，其中$n=a.size()$。下面两份代码都遍历了$vector&lt; int&gt; a$，并输出他的所有元素。1234for(int i=0; i&lt;a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; endl;for(vector&lt;int&gt;::iterator it=a.begin(); it!a.end(); it++) cout &lt;&lt; *it &lt;&lt; endl; front/back$front$函数返回$vector$的第一个元素，等价于$*a.begin()$和$a[0]$。$back$函数返回$vector$的最后一个元素，等价于*—a.end()和a[a.size()-1]. push_back/pop_backa.push_back(x)把元素$x$插入到vector a的尾部。a.pop_back()删除vector a的最后一个元素。 queue 方法 描述 示例 时间复杂度 push 入队(从队尾) q.push(element); O(1) pop 出队(从队头) q.pop(); O(1) front 队头元素 int x = q.front(); O(1) back 队尾元素 int y = q.back(); O(1) priority_queuepriority_queue可理解为一个大根二叉堆。 方法 描述 示例 时间复杂度 push 把元素插入堆 q.push(x); O(logn) pop 删除堆顶元素 q.pop(); O(logn) top 查询堆顶元素(最大值) int x = q.top(); O(1) priority_queue实现小根堆有两种方式。 将插入的元素取反插入； 重载“&lt;”运算符。 重载“&lt;”运算符priority_queue中存储的元素必须定于“小于号”，较大的元素会被放在堆顶。内置的int,string等类型本身就可以比较大下。若使用自定义的结构体类型，则需要重载“&lt;”运算符。例如下面的poi结构体保存了二维平面上的点的编号和坐标，比较大小时，先比横坐标，再比纵坐标，并且考虑了精度误差。12345678struct poi &#123; int id; double x, y;&#125;;bool operator &lt;(const poi &amp;a, const poi &amp;b)&#123; return a.x+eps&lt;b.x || a.x&lt;b.x+eps &amp;&amp; a.y&lt;b.y;&#125; deque 方法 描述 示例 时间复杂度 [] 随机访问 与vector类似 O(1) begin/end deque的头/尾迭代器 与vector迭代器类似 O(1) front/back 队头/队尾元素 与queue类似 O(1) push_back 从队尾入队 q.push_back(x); O(1) push_front 从队头入队 q.push_front(x); O(1) pop_front 从队头出队 q.pop_front(); O(1) pop_back 从队尾出队 q.pop_back(); O(1) clear 清空队列 q.clear(); O(1) set头文件set主要包括set和multiset两个容器，分别是“有序集合”和“有序多重集”，即前者的元素不能重复，而后者可以包含若干个相等的元素。set和multiset的内部实现是一颗红黑树，他们支持的函数基本相同。 size/empty/clear与vector类似，分别为元素个数、是否为空、清空。前两者的时间复杂度为O(1)。 迭代器set和multiset的迭代器称为“双向访问迭代器”，不支持“随机访问”，支持星号解除引用，仅支持“++”和“—”两个与算术相关的操作。设it是一个迭代器，例如set&lt; int&gt;::iterator it;若把it++，则it将会指向“下一个”元素。这里的“下一个”是指在元素从小到大排序的结果中，排在it下一名的元素。同理，若把it—，则it将会指向排在“上一个”的元素。++与—操作符的时间复杂度都是$O(logn)$。执行操作前后，务必仔细检查，避免迭代器指向的位置超出首、尾迭代器之间的范围。 begin/end返回集合的首、尾迭代器，时间复杂度为O(1)。s.begin()是指向集合中最小元素的迭代器。s.end()是指向集合中最大元素下一个位置的迭代器。(stl都是前开后闭) inserts.insert(x)把一个元素x插入到集合s中，时间复杂度为O(logn)。在set中，若元素存在，则不会重复插入该元素，对集合的状态无影响。下面的代码把n个整数插入有序多重集multiset，并从小到大输出，时间复杂度为O(nlogn)，相当于进行了一次排序。假设n个整数目前存储在数组a[1\cdots n]中。12345multiset&lt;int&gt; s;for(int i=1; i&lt;=n; i++) s.insert(a[i]);for(multiset&lt;int&gt;::iterator it=s.begin(); it!=s.end(); it++) cout &lt;&lt; *it &lt;&lt; endl; finds.find(x)在集合s中查找等于x元素，并返回指向该元素的迭代器。若不存在，则返回s.end()。时间复杂度O(logn)。 erase设it是一个迭代器，s.erase(it)从s中删除迭代器it指向的元素，时间复杂度为O(k+logn)。设x是一个元素，s.erase(x)从s中删除所有等于x的元素，时间复杂度为O(k+logn)，其中k为被删除的元素个数。如果想从multiset中删掉至多1个等于x的元素，可以执行：if((it=s.find(x))!=s.end()) s.erase(it); counts.count(x)返回集合s中等于x的元素个数，时间复杂度为O(k+logn)，其中k为元素x的个数。 mapmap容器是一个键值对(key-value)映射。其内部实现是一棵以key为关键码的红黑树。map的key和value可以是任意类型，其中key必须定义“小于号”运算符。 size/empty/clear/begin/end与set类似，分别为元素个数、是否为空、清空、首迭代器、尾迭代器。 迭代器map的迭代器与set一样，也是“双向访问迭代器”。对map的迭代器解除引用后，将得到一个二元组pair&lt; key_type,value_type&gt;。 insert/erase与set类似，分别为插入、删除。insert的参数是pair&lt; key_type,value_type&gt;，erase的参数可以是pair或者迭代器。12345678map&lt;int,int&gt; h;h.insert(make_pair(1,2));h.insert(make_pair(2,3));map&lt;int,int&gt;::iterator it = h.begin();pair&lt;int,int&gt; p = *it;h.erase(it);h.erase(make_pair(2,3));cout &lt;&lt; p.first &lt;&lt; &apos; &apos; &lt;&lt; p.second &lt;&lt; endl; findh.find(x)在变量名为h的map中查找key为x的二元组，并返回指向该二元组的迭代器。若不存在，返回h.end()。时间复杂度为O(logn)。 [ ]操作符h[key]返回key映射到value的引用，时间复杂度为O(logn)。[ ]操作符是map最吸引人的地方。我们可以很方便地通过h[key]来得到key对应的value，还可以对h[key]进行赋值操作，改变key对应的value。需要特别注意的是，若查找的key不存在，则执行h[key]后，h会自动新建一个二元组(key,zero)，并返回zero的引用。这里zero表示一个广义的“零值”。如果查找之后不对h[key]进行赋值，那么时间一长，h会包含很多无用的“零值二元组”，白白地占用了空间，降低了程序运行效率。强烈建议在用[ ]操作符查询之前，先用find方法检查key的存在性。tips：还可以用count检查key的存在性。 用map统计字符串中字符出现的次数给定n个字符，m个问题，每个问题询问一个字符出现的次数。123456789101112131415map&lt;string, int&gt; h;char str[1005];for(int i=1; i&lt;=n; i++)&#123; cin &gt;&gt; str[i]; h[str]++;&#125;for(int i=1; i&lt;=m; i++)&#123; cin &gt;&gt; str; if(h.find(str)==h.end()) puts(&quot;0&quot;); else printf(&quot;%d\n&quot;, h[str]);&#125; bitsetbitset可以看作一个多位二进制数，每8位占用1个字节，相当于采用了状态压缩的二进制数组，并支持基本的位运算。在估算程序运行时间时，我们一般以32位整数的运算次数为基础，因此n位bitset执行一次位运算的复杂度可视为n/32，效率较高。 声明bitset s;表示一个10000位二进制数，&lt;&gt;中填写位数。下面把位数记为n。位运算操作符～s：返回对bitset s 按位取反的结果。&amp;,|,^：返回对两个位数相同的bitset执行按位与、或、异或运算的结果。>&gt;,&lt;&lt;：返回把一个bitset右移、左移若干位的结果。==，!=：比较两个bitset代表的二进制数是否相等。 [ ]操作符s[k]表示s的第k位，既可以取值，也可以赋值。在10000位二进制数中，最低位为s[0]，最高位为s[9999]。 counts.count()返回有多少位1。 any/none若s所有位都为0，则s.any()返回false，s.none()返回true。若s至少一位为1，则s.any()返回ture，s.none()返回false。 set/reset/flips.set()把所有位变为1。s.set(k,v)把s的第k位改为v，即s[k]=v。s.reset()把s所有位变为0。s.reset(k)把s的第k位变为0，即s[k]=0。s.flip()把s所有位取反，即s=～s。s.flip(k)把s的第k位取反，即s[k]^=1。 algorithmreverse翻转一个vector：reverse(a.begin(),a.end());翻转一个数组：reverse(a+1,a+n+1); unique返回去重之后的尾迭代器（或指针），仍然位前闭后开，即这个尾迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，利用迭代器（或指针）的减法，可算出去重后的元素个数m。把一个vector去重：int m = unique(a.begin(),a,end()) - a.begin();把一个数组去重，元素存放在下标1-n：int m = unique(a+1,a+n+1) - (a+1); random_shuffle随机打乱与reverse用法相同。 next_permutation下一个排列把两个迭代器（或指针）指定的部分看作一个排列，求出这些元素构成的全排列中，字典序排在下一个的排列，并直接在序列上更新。另外，若不存在排名更靠后的排列，则返回false，否则返回true。同理也有prev_permutation函数。 下面按照字典序输出1-n的n!种全排列12345678for(int i=1; i&lt;=n; i++) a[i] = i;do&#123; for(int i=1; i&lt;=n; i++) cout &lt;&lt; a[i] &lt;&lt; &apos; &apos;; cout &lt;&lt; a[n] &lt;&lt; endl;&#125;while(next_permutation(a+1,a+n+1)); sort123456789struct rec &#123; int id, x, y;&#125;;vector&lt;rec&gt; a;bool operator &lt;(const rec &amp;a, const rec &amp;b)&#123; return a.x&lt;b.x || a.x==b.x &amp;&amp; a.y&lt;b.y;&#125;sort(a.begin(), a.end()); 函数使用insert()C++容器的insert()函数有以下三种用法：最终*it=val; 用法1：在制定位置it前“插入”职位val的元素，返回指向这个元素的迭代器。iterator insert(iterator it, const TYPE &amp;val); 用法2：在指定位置it前“插入”num个值为val的元素。void insert(iterator it, size_type num, const TYPE &amp;val); 用法3：在指定位置it前插入区间[start, end)的所有元素。void insert(iterator it, input_iterator start, input_iterator end);]]></content>
      <categories>
        <category>ACM</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inversion Counting]]></title>
    <url>%2FACM%2F%E9%80%86%E5%85%83%2FInversion-Counting%2F</url>
    <content type="text"><![CDATA[D. Inversion Counting $time$ $limit$ $per$ $test$ : $2$ $seconds$$memory$ $limit$ $per$ $test$ : $256$ $megabytes$$input$ : $standard$ $input$$output$ : $standard$ $output$ A permutation of size $n$ is an array of size $n$ such that each integer from $1$ to $n$ occurs exactly once in this array. An inversion in a permutation $p$ is a pair of indices $(i, j)$ such that $i &lt; j$ and $a_i &lt; a_j$. For example, a permutation $[4, 1, 3, 2]$ contains $4$ inversions: $(2, 1)$, $(3, 1)$, $(4, 1)$, $(4, 3)$. You are given a permutation a of size $n$ and $m$ queries to it. Each query is represented by two indices $l$ and $r$ denoting that you have to reverse the segment $[l, r]$ of the permutation. For example, if $a = [1, 2, 3, 4]$ and a query $l = 2$, $r = 4$ is applied, then the resulting permutation is $[1, 4, 3, 2]$. After each query you have to determine whether the number of inversions is odd or even. InputThe first line contains one integer $n$ $(1 \leq n \leq 1500)$ — the size of the permutation. The second line contains $n$ integers $a_1, a_2, \cdots , a_n$ $(1 \leq a_i \leq n)$ — the elements of the permutation. These integers are pairwise distinct. The third line contains one integer $m$ $(1 \leq m \leq 2·10^5)$ — the number of queries to process. Then m lines follow, $i-th$ line containing two integers $l_i, r_i (1 \leq l_i \leq r_i \leq n)$ denoting that $i-th$ query is to reverse a segment $[l_i, r_i]$ of the permutation. All queries are performed one after another. OutputPrint $m$ lines. $i-th$ of them must be equal to odd if the number of inversions in the permutation after $i-th$ query is odd, and even otherwise. Sample Input$3$$1$ $2$ $3$$2$$1$ $2$$2$ $3$ $4$$1$ $2$ $4$ $3$$4$$1$ $1$$1$ $4$$1$ $4$$2$ $3$ Sample Output$odd$$even$ $odd$$odd$$odd$$even$ HintThe first example:after the first query $a = [2, 1, 3]$, inversion: $(2, 1)$;after the second query $a = [2, 3, 1]$, inversions: $(3, 1)$, $(3, 2)$. The second example:$a = [1, 2, 4, 3]$, inversion: $(4, 3)$;$a = [3, 4, 2, 1]$, inversions: $(3, 1)$, $(4, 1)$, $(3, 2)$, $(4, 2)$, $(4, 3)$;$a = [1, 2, 4, 3]$, inversion: $(4, 3)$;$a = [1, 4, 2, 3]$, inversions: $(3, 2)$, $(4, 2)$. Analyses这题涉及到逆元的求解问题，可以采用$树状数组$或者$归并排序$来求。 此处抄袭某大佬的题解：思维题目：首先求出区间的长度$len=r−l+1$，那么区间内共有$tot=\frac{len\times (len-1)}{2}$个数对。若tot 为奇数，则不管该区间有多少个逆序对，翻转区间后逆序对数奇偶性改变； 若为偶数，则不变。所以我们可以先暴力求出整体逆序对数，再对区间进行以上处理。 记得当时把题的结果给算了出来，结果疯狂tle\cdots没想到这题还可以暴力过 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;list&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;#define ms(s) memset(s, 0, sizeof(s))const int inf = 0x3f3f3f3f;const int maxn = 10005;int s[maxn], tmp[maxn], ans=0;int m, n;void merge_sort(int l, int r, int mid)&#123; int i=l, j=mid+1; int res = 0; while(i&lt;=mid &amp;&amp; j&lt;=r) &#123; if(s[i]&gt;s[j]) &#123; tmp[res++] = s[j++]; ans += mid-i+1; &#125; else &#123; tmp[res++] = s[i++]; &#125; &#125; while(i&lt;=mid) tmp[res++] = s[i++]; while(j&lt;=r) tmp[res++] = s[j++]; for(int i=0; i&lt;res; i++) s[l+i] = tmp[i];&#125;void merge(int l, int r)&#123; if(l==r) return; int mid = l+(r-l)/2; merge(l, mid); merge(mid+1, r); merge_sort(l, r, mid);&#125;int main(int argc, char * argv[]) &#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; for(int i=0; i&lt;n; i++) cin &gt;&gt; s[i]; merge(0, n-1); cin &gt;&gt; m; while(m--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; int len = b-a+1; int tot = len*(len-1)/2; if(tot%2==0) &#123; if(ans%2==0) cout &lt;&lt; &quot;even&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;odd&quot; &lt;&lt; endl; &#125; else &#123; ans++; if(ans%2==0) cout &lt;&lt; &quot;even&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;odd&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>逆元</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>Codeforces</tag>
        <tag>归并排序</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字串查询]]></title>
    <url>%2FACM%2F%E5%89%8D%E7%BC%80%E5%92%8C%2F%E5%AD%97%E4%B8%B2%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[字串查询 Time Limit: $3500/3000 MS (Java/Others)$Memory Limit: $262144/262144 K (Java/Others)$ Problem Description度度熊的字符串课堂开始了！要以像度度熊一样的天才为目标，努力奋斗哦！为了检验你是否具备不听课的资质，度度熊准备了一个只包含大写英文字母的字符串$A[1,n]=a_1a_2\cdots a_n$接下来他会向你提出$q$个问题$(l,r)$，你需要回答字符串$A[1,n]=a_1a_2\cdots a_n$内有多少个非空子串是$A[l,r]$的所有非空子串中字典序最小的。这里的非空子串是字符串中由至少一个位置连续的字符组成的子序列，两个子串是不同的当且仅当这两个子串内容不完全相同或者出现在不同的位置。记$|S|$为字符串$S$的长度，对于两个字符串$S$和$T$，定义$S$的字典序比$T$小，当且仅当存在非负整数$k(\leq min(|S|,|T|))$使得$S$的前$K$个字符与$T$的前$k$个字符对应相同，并且要么满足$|S|=k$且$|T|\geq k$，要么满足$k\leq min(|S|,|T|)$且$S$的第$k+1$个字符小。例如”$AA$”的字典序比”$AAA$”小，”$AB$”的字典序比”$BA$”小。 Input第一行包含一个整数$T$，表示有$T$组测试数据。接下来依次描述$T$组测试数据。对于每组测试数据：第一行包含两个整数$n$和$q$表示字符串的长度以及询问的次数。第二行包含一个长为$n$的只包含大写英文字母的字符串$A[1,n]$。接下来$q$行，每行包含两个整数$l_i$，$r_i$，表示第$i$次询问的参数。保证$1\leq T\leq 10，1\leq n，q\leq 10^5，1\leq l_i\leq r_i\leq n$。 output对于每组测试数据，先输出一行信息”Case #x:”(不含引号),其中$x$表示这是第$x$组测试数据，接下来$q$行，每行包含一个整数，表示字符串$A[l,r]$中字典序最小的字串个数，行末不要有多余空格。 Sample Input$1$$2$ $3$$AB$$1$ $1$$1$ $2$$2$ $2$ Sample OutputCase #1:$1$$1$$1$ Analyses本题可以用树状数组或者前缀和来解决，但是由于还不会树状数组，所以$\cdots$前缀和我现在的理解就是打表，虽然打表会很慢，但是对于这种查询次数为$10^5$的题目，打表可以大大减少查询的时间。对于这题每次查询的时间复杂度都限制在了$26$次以内，十分接近$log_n$，所以时间复杂度也就大大降了下来。我用的是一个二维数组存的前缀和$preSum[][]$它的一维表示的是当前指针的位置，二维分别对应$26$个大写英文字母，对于查询区间$[a,b]$,只需要$preSum[b][]-preSum[a-1][]$即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;list&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;#define ms(s) memset(s, 0, sizeof(s))const int inf = 0x3f3f3f3f;const int maxn = 1e5+5;int t, n, q, preSum[maxn][30];char s[maxn];int main(int argc, char * argv[]) &#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; t; int tt = 0; while(t--) &#123; ms(preSum); cin &gt;&gt; n &gt;&gt; q; for(int i=1; i&lt;=n; i++) &#123; cin &gt;&gt; s[i]; preSum[i][s[i]-&apos;A&apos;+1]++; //区分不同的字母，对于不同的一维， //将对应的字母存入不同的二维 &#125; for(int i=1; i&lt;n; i++) &#123; for(int j=1; j&lt;=26; j++) &#123; preSum[i+1][j] += preSum[i][j]; //求解前缀和过程 &#125; &#125; cout &lt;&lt; &quot;Case #&quot; &lt;&lt; ++tt &lt;&lt; &quot;:&quot; &lt;&lt; endl; while(q--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; for(int j=1; j&lt;=26; j++) if(preSum[b][j]-preSum[a-1][j]&gt;0) &#123; cout &lt;&lt; preSum[b][j]-preSum[a-1][j] &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>前缀和</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
</search>
