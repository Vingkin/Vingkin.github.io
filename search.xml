<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux命令]]></title>
    <url>%2Flinux%E5%91%BD%E4%BB%A4%2Flinux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux命令1 mkdir 创建文件夹 mkdir demo 2 ls 显示文件和目录信息 ls -a 查询所有文件，包涵文件名以.开头的隐藏文件 3 cp 将原文件复制到目标文件 cp -r dir1 dir2 复制dir1目录所有东西到dir2 4 rm 删除 rm -r 文件/文件夹 5 find 查找 find 查找位置 -name 文件名 -print 查找文件 find 18300 -name a.cpp -print 6 cat 显示文本文件内容 cat a.cpp 7 less 分页显示文件内容，可用PgDn和PgUp翻页 less a.cpp less -N a.cpp 显示行号 8 groupadd 添加用户组 groupadd vingkin 9 groupdel 删除指定用户组 groupdel vingkin 10 useradd 添加用户 -g 指定用户所属的主用户组 -G 指定用户的附加用户组 -n 取消建立以用户名称为名的用户组 -r 建立系统账号 -s 指定用户登录shell -u 指定用户ID号 -m 自动建立用户登录后的用户主目录 -d 指定用户登陆后的主用户目录 useradd -g g1 -G g2, g3 user1 建立用户user1，g1为主用户组，g2和g3为附加用户组groups user1 显示user1所属的用户组 11 passwd 建立用户的登录密码 passwd user1 设置user1的登录密码 12 ps 显示系统进程的状态和属性 ps -r 显示正在运行的进程 ps -a 显示所有终端上运行的进程 ps -efj 显示所有进程 13 fg 将指定作业号的作业从后台切换至前台 fg 作业号 fg 1 14 bg 将指定作业号的后台暂停进程继续运行 bg 作业号 bg 1 15 jobs 显示当前控制台中的后台进程的状态 jobs]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高斯消元]]></title>
    <url>%2FACM%2F%E6%95%B0%E8%AE%BA%2F%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%2F%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%2F</url>
    <content type="text"><![CDATA[高斯消元 模板 12345678910111213141516171819202122232425262728293031323334// 此模板只能解决有解的情况，// 但是可以通过定义解决无穷解与无解的情况// c[][]储存的是系数矩阵// b[]储存的是尾数矩阵// 最终a[][]是一个对角线矩阵void Gauss()&#123; for(int i=1; i&lt;=n; i++) &#123; for(int j=i; j&lt;=n; j++) &#123; if(fabs(c[j][i])&gt;eps) &#123; for(int k=1; k&lt;=n; k++) &#123; swap(c[i][k], c[j][k]); &#125; swap(b[i], b[j]); &#125; &#125; for(int j=1; j&lt;=n; j++) &#123; if(i==j) continue; double rate = c[j][i]/c[i][i]; for(int k=i; k&lt;=n; k++) c[j][k] -= c[i][k]*rate; b[j] -= b[i]*rate; &#125; &#125; for(int i=1; i&lt;n; i++) printf(&quot;%.3lf &quot;, b[i]/c[i][i]); printf(&quot;%.3lf\n&quot;, b[n]/c[n][n]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盛金公式]]></title>
    <url>%2FACM%2F%E6%95%B0%E8%AE%BA%2F%E7%9B%9B%E9%87%91%E5%85%AC%E5%BC%8F%2F%E7%9B%9B%E9%87%91%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[盛金公式一元三次方程$ax^3+bx^2+cx+d=0(a,b,c,d\in R,a\neq 0)$ 重根判别式 \begin{cases} A=b^2-3ac\\ B=bc-9ad\\ C=c^2-3bd\\ \end{cases}总判别式 $\Delta =B^2-4AC$ 盛金公式1：当A=B=0时，$X_1=X_2=X_3=\frac{-b}{3a}=\frac{-c}{b}=\frac{-3d}{c}$ 盛金公式2：当$\Delta =B^2-4AC&gt;0$时，$X_1=\frac{-b-(\sqrt[3]{Y_1}+\sqrt[3]{Y_2})}{3a}$$X_{2,3}=\frac{-b+\frac{1}{2}(\sqrt[3]{Y_1}+\sqrt[3]{Y_2})\pm \frac{\sqrt[]{3}}{2}(\sqrt[3]{Y_1}-\sqrt[3]{Y_2})i}{3a}$其中$Y_{1,2}=Ab+3a(\frac{-B\pm \sqrt[]{B^2-4AC}}{2}),i^2=-1$。 盛金公式3：当$\Delta =B^2-4AC=0$时，$X_1=\frac{-b}{a}+K$;$X_{2,3}=\frac{-K}{2}$;其中$K=\frac{B}{A},(A\neq 0)$。 盛金公式4：当$\Delta =B^2-4AC&lt;0$时，$X_1=\frac{-b-2\sqrt[]{A}cos\frac{\theta}{3}}{3a}$;$X_{2,3}=\frac{-b+\sqrt[]{A}(cos\frac{\theta}{3}\pm \sqrt[]{3}sin\frac{\theta}{3})}{3a}$;其中$\theta =arccosT$$T=\frac{2Ab-3aB}{2A\sqrt[]{A}}$。]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
        <category>盛金公式</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sonya and Robots]]></title>
    <url>%2FACM%2F%E6%8E%92%E5%BA%8F%2FSonya-and-Robots%2F</url>
    <content type="text"><![CDATA[Sonya and Robots $time$ $limit$ $per$ $test$:$1$ $second$$memory$ $limit$ $per$ $test$:$256$ $megabytes$$input$:$standard$ $input$$output$:$standard$ $output$ Since Sonya is interested in robotics too, she decided to construct robots that will read and recognize numbers. Sonya has drawn $n$ numbers in a row, $a_i$ is located in the $i-th$ position. She also has put a robot at each end of the row (to the left of the first number and to the right of the last number). Sonya will give a number to each robot (they can be either same or different) and run them. When a robot is running, it is moving toward to another robot, reading numbers in the row. When a robot is reading a number that is equal to the number that was given to that robot, it will turn off and stay in the same position. Sonya does not want robots to break, so she will give such numbers that robots will stop before they meet. That is, the girl wants them to stop at different positions so that the first robot is to the left of the second one. For example, if the numbers $[1,5,4,1,3]$ are written, and Sonya gives the number $1$ to the first robot and the number $4$ to the second one, the first robot will stop in the $1-st$ position while the second one in the $3-rd$ position. In that case, robots will not meet each other. As a result, robots will not be broken. But if Sonya gives the number $4$ to the first robot and the number $5$ to the second one, they will meet since the first robot will stop in the $3-rd$ position while the second one is in the $2-nd$ position. Sonya understands that it does not make sense to give a number that is not written in the row because a robot will not find this number and will meet the other robot. Sonya is now interested in finding the number of different pairs that she can give to robots so that they will not meet. In other words, she wants to know the number of pairs $(p,q)$ , where she will give $p$ to the first robot and $q$ to the second one.Pairs $(p_i,q_i)$and $(p_j,q_j)$ are different if $p_i\neq p_j$ or $q_i\neq q_j$. Unfortunately, Sonya is busy fixing robots that broke after a failed launch. That is why she is asking you to find the number of pairs that she can give to robots so that they will not meet. InputThe first line contains a single integer $n$ $(1\leq n\leq 10^5)$ — the number of numbers in a row.The second line contains $n$ integers $a_1,a_2,\cdots ,a_n(1\leq a_i\leq 10^5)$ — the numbers in a row. OutputPrint one number — the number of possible pairs that Sonya can give to robots so that they will not meet. Examples Input 5 1 5 4 1 3 Output 9 Input 7 1 2 1 1 1 3 2 Output 7 HintIn the first example, Sonya can give pairs $(1,1)$,$(1,3)$,$(1,4)$,$(1,5)$,$(4,1)$,$(4,3)$,$(5,1)$,$(5,3)$,and$(5,4)$.In the second example, Sonya can give pairs $(1,1)$,$(1,2)$,$(1,3)$,$(2,1)$,$(2,2)$,$(2,3)$,and$(3,2)$. Analyses这题的题意是给你一个序列，你需要组成一个数对，数对满足不能重复，不能与自己组，而且数对左边的数在原序列上也在右边的数的左边，也就是相对位置不能改变。这题刚开始还不会写，还是太菜了啊，或许是stl还不会用，看一个wf大佬的代码后恍然大悟，对set又有了更深的认识，红黑树牛皮，不得不说set在去重和排序上还是很强的。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;list&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;#define ms(s) memset(s, 0, sizeof(s))const int inf = 0x3f3f3f3f;const int maxn = 1e5+5;ll s[maxn], n, ans=0;ll num[maxn];set&lt;int&gt; a;int main(int argc, char * argv[]) &#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; for(int i=1; i&lt;=n; i++) cin &gt;&gt; s[i]; for(int i=n; i&gt;=1; i--) &#123; a.insert(s[i]); num[i] = a.size(); &#125; a.clear(); for(int i=1; i&lt;=n; i++) &#123; if(a.find(s[i])==a.end()) &#123; a.insert(s[i]); ans += num[i+1]; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL]]></title>
    <url>%2FACM%2FSTL%2FSTL%2F</url>
    <content type="text"><![CDATA[C++ STLvectorsize/empty$size$函数返回$vector$的实际长度(包含的元素个数)，$empty$函数返回一个$bool$类型，表明$vector$是否为空。二者的时间复杂度都是$O(1)$;所有的STL容器都有这两个方法，含义也相同。 clear$clear$函数把$vector$数组清空。 迭代器迭代器就像STL容器的“指针”，可以用星号“*”操作符解除引用。一个保存$int$的$vector$的迭代器声明方法为：vector&lt; int&gt;::iterator it;$vector$的迭代器是“随机访问迭代器”，可以把$vector$的迭代器与一个整数相加减，其行为和指针的移动类似。可以把$vector$的两个迭代器相减，其结果也和指针相减类似，得到两个迭代器对应下标之间的距离。 begin/end$begin$函数返回指向$vector$中第一个元素的迭代器。例如$a$是一个非空的$vector$，则$*a.begin()$与$a[0]$的作用相同。所有的容器都可以视作一个“前闭后开”的结构，$end$函数返回$vector$的尾部，即第$n$个元素再往后的“边界”。$*end()$与$a[n]$都是越界访问，其中$n=a.size()$。下面两份代码都遍历了$vector&lt; int&gt; a$，并输出他的所有元素。1234for(int i=0; i&lt;a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; endl;for(vector&lt;int&gt;::iterator it=a.begin(); it!a.end(); it++) cout &lt;&lt; *it &lt;&lt; endl; front/back$front$函数返回$vector$的第一个元素，等价于$*a.begin()$和$a[0]$。$back$函数返回$vector$的最后一个元素，等价于*—a.end()和a[a.size()-1]. push_back/pop_backa.push_back(x)把元素$x$插入到vector a的尾部。a.pop_back()删除vector a的最后一个元素。 queue 方法 描述 示例 时间复杂度 push 入队(从队尾) q.push(element); O(1) pop 出队(从队头) q.pop(); O(1) front 队头元素 int x = q.front(); O(1) back 队尾元素 int y = q.back(); O(1) priority_queuepriority_queue可理解为一个大根二叉堆。 方法 描述 示例 时间复杂度 push 把元素插入堆 q.push(x); O(logn) pop 删除堆顶元素 q.pop(); O(logn) top 查询堆顶元素(最大值) int x = q.top(); O(1) priority_queue实现小根堆有两种方式。 将插入的元素取反插入； 重载“&lt;”运算符。 重载“&lt;”运算符priority_queue中存储的元素必须定于“小于号”，较大的元素会被放在堆顶。内置的int,string等类型本身就可以比较大下。若使用自定义的结构体类型，则需要重载“&lt;”运算符。例如下面的poi结构体保存了二维平面上的点的编号和坐标，比较大小时，先比横坐标，再比纵坐标，并且考虑了精度误差。12345678struct poi &#123; int id; double x, y;&#125;;bool operator &lt;(const poi &amp;a, const poi &amp;b)&#123; return a.x+eps&lt;b.x || a.x&lt;b.x+eps &amp;&amp; a.y&lt;b.y;&#125; deque 方法 描述 示例 时间复杂度 [] 随机访问 与vector类似 O(1) begin/end deque的头/尾迭代器 与vector迭代器类似 O(1) front/back 队头/队尾元素 与queue类似 O(1) push_back 从队尾入队 q.push_back(x); O(1) push_front 从队头入队 q.push_front(x); O(1) pop_front 从队头出队 q.pop_front(); O(1) pop_back 从队尾出队 q.pop_back(); O(1) clear 清空队列 q.clear(); O(1) set头文件set主要包括set和multiset两个容器，分别是“有序集合”和“有序多重集”，即前者的元素不能重复，而后者可以包含若干个相等的元素。set和multiset的内部实现是一颗红黑树，他们支持的函数基本相同。 size/empty/clear与vector类似，分别为元素个数、是否为空、清空。前两者的时间复杂度为O(1)。 迭代器set和multiset的迭代器称为“双向访问迭代器”，不支持“随机访问”，支持星号解除引用，仅支持“++”和“—”两个与算术相关的操作。设it是一个迭代器，例如set&lt; int&gt;::iterator it;若把it++，则it将会指向“下一个”元素。这里的“下一个”是指在元素从小到大排序的结果中，排在it下一名的元素。同理，若把it—，则it将会指向排在“上一个”的元素。++与—操作符的时间复杂度都是$O(logn)$。执行操作前后，务必仔细检查，避免迭代器指向的位置超出首、尾迭代器之间的范围。 begin/end返回集合的首、尾迭代器，时间复杂度为O(1)。s.begin()是指向集合中最小元素的迭代器。s.end()是指向集合中最大元素下一个位置的迭代器。(stl都是前开后闭) inserts.insert(x)把一个元素x插入到集合s中，时间复杂度为O(logn)。在set中，若元素存在，则不会重复插入该元素，对集合的状态无影响。下面的代码把n个整数插入有序多重集multiset，并从小到大输出，时间复杂度为O(nlogn)，相当于进行了一次排序。假设n个整数目前存储在数组a[1\cdots n]中。12345multiset&lt;int&gt; s;for(int i=1; i&lt;=n; i++) s.insert(a[i]);for(multiset&lt;int&gt;::iterator it=s.begin(); it!=s.end(); it++) cout &lt;&lt; *it &lt;&lt; endl; finds.find(x)在集合s中查找等于x元素，并返回指向该元素的迭代器。若不存在，则返回s.end()。时间复杂度O(logn)。 erase设it是一个迭代器，s.erase(it)从s中删除迭代器it指向的元素，时间复杂度为O(k+logn)。设x是一个元素，s.erase(x)从s中删除所有等于x的元素，时间复杂度为O(k+logn)，其中k为被删除的元素个数。如果想从multiset中删掉至多1个等于x的元素，可以执行：if((it=s.find(x))!=s.end()) s.erase(it); counts.count(x)返回集合s中等于x的元素个数，时间复杂度为O(k+logn)，其中k为元素x的个数。 mapmap容器是一个键值对(key-value)映射。其内部实现是一棵以key为关键码的红黑树。map的key和value可以是任意类型，其中key必须定义“小于号”运算符。 size/empty/clear/begin/end与set类似，分别为元素个数、是否为空、清空、首迭代器、尾迭代器。 迭代器map的迭代器与set一样，也是“双向访问迭代器”。对map的迭代器解除引用后，将得到一个二元组pair&lt; key_type,value_type&gt;。 insert/erase与set类似，分别为插入、删除。insert的参数是pair&lt; key_type,value_type&gt;，erase的参数可以是pair或者迭代器。12345678map&lt;int,int&gt; h;h.insert(make_pair(1,2));h.insert(make_pair(2,3));map&lt;int,int&gt;::iterator it = h.begin();pair&lt;int,int&gt; p = *it;h.erase(it);h.erase(make_pair(2,3));cout &lt;&lt; p.first &lt;&lt; &apos; &apos; &lt;&lt; p.second &lt;&lt; endl; findh.find(x)在变量名为h的map中查找key为x的二元组，并返回指向该二元组的迭代器。若不存在，返回h.end()。时间复杂度为O(logn)。 [ ]操作符h[key]返回key映射到value的引用，时间复杂度为O(logn)。[ ]操作符是map最吸引人的地方。我们可以很方便地通过h[key]来得到key对应的value，还可以对h[key]进行赋值操作，改变key对应的value。需要特别注意的是，若查找的key不存在，则执行h[key]后，h会自动新建一个二元组(key,zero)，并返回zero的引用。这里zero表示一个广义的“零值”。如果查找之后不对h[key]进行赋值，那么时间一长，h会包含很多无用的“零值二元组”，白白地占用了空间，降低了程序运行效率。强烈建议在用[ ]操作符查询之前，先用find方法检查key的存在性。tips：还可以用count检查key的存在性。 用map统计字符串中字符出现的次数给定n个字符，m个问题，每个问题询问一个字符出现的次数。123456789101112131415map&lt;string, int&gt; h;char str[1005];for(int i=1; i&lt;=n; i++)&#123; cin &gt;&gt; str[i]; h[str]++;&#125;for(int i=1; i&lt;=m; i++)&#123; cin &gt;&gt; str; if(h.find(str)==h.end()) puts(&quot;0&quot;); else printf(&quot;%d\n&quot;, h[str]);&#125; bitsetbitset可以看作一个多位二进制数，每8位占用1个字节，相当于采用了状态压缩的二进制数组，并支持基本的位运算。在估算程序运行时间时，我们一般以32位整数的运算次数为基础，因此n位bitset执行一次位运算的复杂度可视为n/32，效率较高。 声明bitset s;表示一个10000位二进制数，&lt;&gt;中填写位数。下面把位数记为n。位运算操作符～s：返回对bitset s 按位取反的结果。&amp;,|,^：返回对两个位数相同的bitset执行按位与、或、异或运算的结果。>&gt;,&lt;&lt;：返回把一个bitset右移、左移若干位的结果。==，!=：比较两个bitset代表的二进制数是否相等。 [ ]操作符s[k]表示s的第k位，既可以取值，也可以赋值。在10000位二进制数中，最低位为s[0]，最高位为s[9999]。 counts.count()返回有多少位1。 any/none若s所有位都为0，则s.any()返回false，s.none()返回true。若s至少一位为1，则s.any()返回ture，s.none()返回false。 set/reset/flips.set()把所有位变为1。s.set(k,v)把s的第k位改为v，即s[k]=v。s.reset()把s所有位变为0。s.reset(k)把s的第k位变为0，即s[k]=0。s.flip()把s所有位取反，即s=～s。s.flip(k)把s的第k位取反，即s[k]^=1。 algorithmreverse翻转一个vector：reverse(a.begin(),a.end());翻转一个数组：reverse(a+1,a+n+1); unique返回去重之后的尾迭代器（或指针），仍然位前闭后开，即这个尾迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，利用迭代器（或指针）的减法，可算出去重后的元素个数m。把一个vector去重：int m = unique(a.begin(),a,end()) - a.begin();把一个数组去重，元素存放在下标1-n：int m = unique(a+1,a+n+1) - (a+1); random_shuffle随机打乱与reverse用法相同。 next_permutation下一个排列把两个迭代器（或指针）指定的部分看作一个排列，求出这些元素构成的全排列中，字典序排在下一个的排列，并直接在序列上更新。另外，若不存在排名更靠后的排列，则返回false，否则返回true。同理也有prev_permutation函数。 下面按照字典序输出1-n的n!种全排列12345678for(int i=1; i&lt;=n; i++) a[i] = i;do&#123; for(int i=1; i&lt;=n; i++) cout &lt;&lt; a[i] &lt;&lt; &apos; &apos;; cout &lt;&lt; a[n] &lt;&lt; endl;&#125;while(next_permutation(a+1,a+n+1)); sort123456789struct rec &#123; int id, x, y;&#125;;vector&lt;rec&gt; a;bool operator &lt;(const rec &amp;a, const rec &amp;b)&#123; return a.x&lt;b.x || a.x==b.x &amp;&amp; a.y&lt;b.y;&#125;sort(a.begin(), a.end()); 函数使用insert()C++容器的insert()函数有以下三种用法：最终*it=val; 用法1：在制定位置it前“插入”职位val的元素，返回指向这个元素的迭代器。iterator insert(iterator it, const TYPE &amp;val); 用法2：在指定位置it前“插入”num个值为val的元素。void insert(iterator it, size_type num, const TYPE &amp;val); 用法3：在指定位置it前插入区间[start, end)的所有元素。void insert(iterator it, input_iterator start, input_iterator end);]]></content>
      <categories>
        <category>ACM</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inversion Counting]]></title>
    <url>%2FACM%2F%E9%80%86%E5%85%83%2FInversion-Counting%2F</url>
    <content type="text"><![CDATA[D. Inversion Counting $time$ $limit$ $per$ $test$ : $2$ $seconds$$memory$ $limit$ $per$ $test$ : $256$ $megabytes$$input$ : $standard$ $input$$output$ : $standard$ $output$ A permutation of size $n$ is an array of size $n$ such that each integer from $1$ to $n$ occurs exactly once in this array. An inversion in a permutation $p$ is a pair of indices $(i, j)$ such that $i &lt; j$ and $a_i &lt; a_j$. For example, a permutation $[4, 1, 3, 2]$ contains $4$ inversions: $(2, 1)$, $(3, 1)$, $(4, 1)$, $(4, 3)$. You are given a permutation a of size $n$ and $m$ queries to it. Each query is represented by two indices $l$ and $r$ denoting that you have to reverse the segment $[l, r]$ of the permutation. For example, if $a = [1, 2, 3, 4]$ and a query $l = 2$, $r = 4$ is applied, then the resulting permutation is $[1, 4, 3, 2]$. After each query you have to determine whether the number of inversions is odd or even. InputThe first line contains one integer $n$ $(1 \leq n \leq 1500)$ — the size of the permutation. The second line contains $n$ integers $a_1, a_2, \cdots , a_n$ $(1 \leq a_i \leq n)$ — the elements of the permutation. These integers are pairwise distinct. The third line contains one integer $m$ $(1 \leq m \leq 2·10^5)$ — the number of queries to process. Then m lines follow, $i-th$ line containing two integers $l_i, r_i (1 \leq l_i \leq r_i \leq n)$ denoting that $i-th$ query is to reverse a segment $[l_i, r_i]$ of the permutation. All queries are performed one after another. OutputPrint $m$ lines. $i-th$ of them must be equal to odd if the number of inversions in the permutation after $i-th$ query is odd, and even otherwise. Sample Input$3$$1$ $2$ $3$$2$$1$ $2$$2$ $3$ $4$$1$ $2$ $4$ $3$$4$$1$ $1$$1$ $4$$1$ $4$$2$ $3$ Sample Output$odd$$even$ $odd$$odd$$odd$$even$ HintThe first example:after the first query $a = [2, 1, 3]$, inversion: $(2, 1)$;after the second query $a = [2, 3, 1]$, inversions: $(3, 1)$, $(3, 2)$. The second example:$a = [1, 2, 4, 3]$, inversion: $(4, 3)$;$a = [3, 4, 2, 1]$, inversions: $(3, 1)$, $(4, 1)$, $(3, 2)$, $(4, 2)$, $(4, 3)$;$a = [1, 2, 4, 3]$, inversion: $(4, 3)$;$a = [1, 4, 2, 3]$, inversions: $(3, 2)$, $(4, 2)$. Analyses这题涉及到逆元的求解问题，可以采用$树状数组$或者$归并排序$来求。 此处抄袭某大佬的题解：思维题目：首先求出区间的长度$len=r−l+1$，那么区间内共有$tot=\frac{len\times (len-1)}{2}$个数对。若tot 为奇数，则不管该区间有多少个逆序对，翻转区间后逆序对数奇偶性改变； 若为偶数，则不变。所以我们可以先暴力求出整体逆序对数，再对区间进行以上处理。 记得当时把题的结果给算了出来，结果疯狂tle\cdots没想到这题还可以暴力过 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;list&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;#define ms(s) memset(s, 0, sizeof(s))const int inf = 0x3f3f3f3f;const int maxn = 10005;int s[maxn], tmp[maxn], ans=0;int m, n;void merge_sort(int l, int r, int mid)&#123; int i=l, j=mid+1; int res = 0; while(i&lt;=mid &amp;&amp; j&lt;=r) &#123; if(s[i]&gt;s[j]) &#123; tmp[res++] = s[j++]; ans += mid-i+1; &#125; else &#123; tmp[res++] = s[i++]; &#125; &#125; while(i&lt;=mid) tmp[res++] = s[i++]; while(j&lt;=r) tmp[res++] = s[j++]; for(int i=0; i&lt;res; i++) s[l+i] = tmp[i];&#125;void merge(int l, int r)&#123; if(l==r) return; int mid = l+(r-l)/2; merge(l, mid); merge(mid+1, r); merge_sort(l, r, mid);&#125;int main(int argc, char * argv[]) &#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; for(int i=0; i&lt;n; i++) cin &gt;&gt; s[i]; merge(0, n-1); cin &gt;&gt; m; while(m--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; int len = b-a+1; int tot = len*(len-1)/2; if(tot%2==0) &#123; if(ans%2==0) cout &lt;&lt; &quot;even&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;odd&quot; &lt;&lt; endl; &#125; else &#123; ans++; if(ans%2==0) cout &lt;&lt; &quot;even&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;odd&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>逆元</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>Codeforces</tag>
        <tag>归并排序</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字串查询]]></title>
    <url>%2FACM%2F%E5%89%8D%E7%BC%80%E5%92%8C%2F%E5%AD%97%E4%B8%B2%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[字串查询 Time Limit: $3500/3000 MS (Java/Others)$Memory Limit: $262144/262144 K (Java/Others)$ Problem Description度度熊的字符串课堂开始了！要以像度度熊一样的天才为目标，努力奋斗哦！为了检验你是否具备不听课的资质，度度熊准备了一个只包含大写英文字母的字符串$A[1,n]=a_1a_2\cdots a_n$接下来他会向你提出$q$个问题$(l,r)$，你需要回答字符串$A[1,n]=a_1a_2\cdots a_n$内有多少个非空子串是$A[l,r]$的所有非空子串中字典序最小的。这里的非空子串是字符串中由至少一个位置连续的字符组成的子序列，两个子串是不同的当且仅当这两个子串内容不完全相同或者出现在不同的位置。记$|S|$为字符串$S$的长度，对于两个字符串$S$和$T$，定义$S$的字典序比$T$小，当且仅当存在非负整数$k(\leq min(|S|,|T|))$使得$S$的前$K$个字符与$T$的前$k$个字符对应相同，并且要么满足$|S|=k$且$|T|\geq k$，要么满足$k\leq min(|S|,|T|)$且$S$的第$k+1$个字符小。例如”$AA$”的字典序比”$AAA$”小，”$AB$”的字典序比”$BA$”小。 Input第一行包含一个整数$T$，表示有$T$组测试数据。接下来依次描述$T$组测试数据。对于每组测试数据：第一行包含两个整数$n$和$q$表示字符串的长度以及询问的次数。第二行包含一个长为$n$的只包含大写英文字母的字符串$A[1,n]$。接下来$q$行，每行包含两个整数$l_i$，$r_i$，表示第$i$次询问的参数。保证$1\leq T\leq 10，1\leq n，q\leq 10^5，1\leq l_i\leq r_i\leq n$。 output对于每组测试数据，先输出一行信息”Case #x:”(不含引号),其中$x$表示这是第$x$组测试数据，接下来$q$行，每行包含一个整数，表示字符串$A[l,r]$中字典序最小的字串个数，行末不要有多余空格。 Sample Input$1$$2$ $3$$AB$$1$ $1$$1$ $2$$2$ $2$ Sample OutputCase #1:$1$$1$$1$ Analyses本题可以用树状数组或者前缀和来解决，但是由于还不会树状数组，所以$\cdots$前缀和我现在的理解就是打表，虽然打表会很慢，但是对于这种查询次数为$10^5$的题目，打表可以大大减少查询的时间。对于这题每次查询的时间复杂度都限制在了$26$次以内，十分接近$log_n$，所以时间复杂度也就大大降了下来。我用的是一个二维数组存的前缀和$preSum[][]$它的一维表示的是当前指针的位置，二维分别对应$26$个大写英文字母，对于查询区间$[a,b]$,只需要$preSum[b][]-preSum[a-1][]$即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;list&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;#define ms(s) memset(s, 0, sizeof(s))const int inf = 0x3f3f3f3f;const int maxn = 1e5+5;int t, n, q, preSum[maxn][30];char s[maxn];int main(int argc, char * argv[]) &#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; t; int tt = 0; while(t--) &#123; ms(preSum); cin &gt;&gt; n &gt;&gt; q; for(int i=1; i&lt;=n; i++) &#123; cin &gt;&gt; s[i]; preSum[i][s[i]-&apos;A&apos;+1]++; //区分不同的字母，对于不同的一维， //将对应的字母存入不同的二维 &#125; for(int i=1; i&lt;n; i++) &#123; for(int j=1; j&lt;=26; j++) &#123; preSum[i+1][j] += preSum[i][j]; //求解前缀和过程 &#125; &#125; cout &lt;&lt; &quot;Case #&quot; &lt;&lt; ++tt &lt;&lt; &quot;:&quot; &lt;&lt; endl; while(q--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; for(int j=1; j&lt;=26; j++) if(preSum[b][j]-preSum[a-1][j]&gt;0) &#123; cout &lt;&lt; preSum[b][j]-preSum[a-1][j] &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>前缀和</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
</search>
